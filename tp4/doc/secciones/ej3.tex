\section{Ejercicio 3}

\subsection{Enunciado}

El rey de Nlogonia nos ha encomendado la siguiente tarea: Dado un conjunto de lugares históricos, y lugares enemigos, calcular la mejor muralla (un polígono convexo) que no contenga lugares enemigos, donde entendemos por mejor a aquella que contenga mas cantidad de lugares históricos en su interior (incluyendo el borde).

La cantidad de lugares históricos se denomina H, la cantidad de enemigos se denomina E, y la suma de estos N.

Debemos imprimir la cantidad de lugares históricos en la mejor muralla.

\subsection{Algunas ideas}
\par{Para demostrar la correctitud de nuestro complejo algoritmo \quotes{Vamos por partes}\footnote{Como diría Jack el Destripador, y cualquier ayudante de Análisis II.}. Daremos una modularización del mismo mediante funciones auxiliares y basaremos la correctitud de ciertas funciones en la correctitud de las que esta utiliza.} 
\par{Como primer observación principal, vemos que un polígono (más aún, convexo) puede descomponerse en triángulos, como vimos en el ejercicio 1 de este mismo informe. Dada una descomposición en triángulos, podemos chequear cuantos enemigos están contenidos en cada triángulo. De esta manera vamos a buscar cumplir uno de los objetivos, que era no tener enemigos dentro de nuestro polígono resultado. Por otro lado, podemos contar la cantidad de lugares históricos en cada triángulo, y con cierto cuidado de no repetir los vértices de los triángulos, saber cuantos lugares históricos tiene en total un cierto polígono. De esta forma, también podríamos cubrir el objetivo de maximizar la cantidad de lugares históricos.}
\par{Otra observación muy importante es que, si bien contaremos la cantidad de puntos históricos en el mejor polígono, nos restringimos a polígonos convexso cuyos vértices son puntos históricos. Podemos hacer esto ya que, de existir un polígono convexo cuya cantidad de puntos históricos es respuesta y que no le sucede esto, lo podemos \quotes{achicar} hasta encontrarnos con los puntos históricos, de manera de no perder puntos históricos.}

\subsection{Graham's scan: La inspiración divina}
\par{En la presente sección, nos inspiramos y haremos malabares con el algoritmo de Graham\footnote{Ronald Graham es un reconocido malabarista: \url{http://www.math.ucsd.edu/~fan/ron/images/12balls.jpg}}.
En el algoritmo de Graham, tomamos al punto mas abajo, y de estos el mas a la izquierda, como base. Luego construimos una capsula convexa utilizando a este punto para ordenar a los demás según ángulo polar en relación al punto. Podemos pensar entonces en la descomposición en triángulos del polígono convexo resultante, tomando al punto base del algoritmo de Graham, es decir, que este punto esté en todos los triángulos del polígono.}

\par{Dado un punto base, vamos a denominar \textbf{mejor-con-base} a la función que retorna el mejor polígono convexo que contiene solo puntos mas arriba a la derecha de esta base, y que no contiene enemigos. Una vez más, llamamos mejor al que contiene más cantidad de puntos históricos. Diremos que este punto es base porque daremos una descomposición en triángulos con este punto como base(en eso consistirá nuestro algoritmo).}
\par{Como adelantábamos antes, veremos que nuestra función principal (el resultado del problema), que denominamos \textbf{solución}, es correcta. Y para esto vemos que, dado el resultado del problema, el polígono es uno de los considerados por la función mejor-con-base con alguna base, ya que, existe algún punto que es el más abajo a la izquierda de todos los que pertenecen al polígono. Por eso, la función solución solo debe probar todas las posibles bases y retornar el máximo resultado obtenido. En base a la correctitud de mejor-con-base, esta función es correcta.}

\subsection{Función mejor-con-base}
\par{
En esta función vamos a restringirnos a los vértices que están arriba a la derecha del punto base.
Si estos puntos son menos que 3, entonces la respuesta es el tamaño de este mismo conjunto, pues no puede haber puntos colineales, y por ende no puede haber enemigos en su \quotes{interior o borde}.
Veamos entonces el otro caso.}
\par{
Dada cualquier descomposición en triángulos que tomemos con su base, podemos tener un orden en el ángulo de los vértices de los triángulos. Esto mismo nos define un orden sobre los triángulos.
De cierta forma, un polígono convexo respuesta al problema podría ser formado en un Graham's Scan si nos restringimos a los puntos que forman parte de la solución. Pensando en este Graham's scan y el orden anterior, alguno de los triángulos es el último.}
\par{
De una forma similar a la anterior, podemos definir una función \textbf{mejor-con-ultimo}, que nos da el mejor polígono convexo (que cumple las restricciones), y donde tenemos fijo el último triángulo dado un punto base. Como alguno de los puntos es el último, tomamos el máximo sobre todos los posibles triángulos tomándolos como últimos y llamando a la función mejor-con-ultimo con este como parámetro. Así, la función es correcta suponiendo correcta a mejor-con-ultimo.}
\par{
Como estamos tomando los triángulos respecto a un punto base, los triángulos que debemos ver se corresponden con todos los pares de vértices posibles (excepto repetir vértices). Así quedan cubiertos todos los triángulos. }

\subsection{Función mejor-con-ultimo}
\par{Esta función la implementaremos de forma recursiva. Si bien esta recursión puede no ser clásica o no tan clara, es una recursión al fin, con todos sus elementos.
Para empezar, distinguimos el caso de que el último triángulo parámetro contenga un enemigo. En este caso retornamos $-\infty$ (-inf). }
\par{En caso de que no, vamos a tomar el máximo sobre algunas opciones. Sabemos que un posible polígono es únicamente el último triángulo, así que inicializamos la variable res (la respuesta) como el primer posible máximo, que es la cantidad de puntos históricos dentro de este triángulo, incluyendo los vértices.
En caso de no presentarse otras opciones (veremos ahora cuales son), retornamos este valor mencionado para res. Así que este sería nuestro caso base. Como no existe otro posible polígono (nuestras opciones se corresponden con todos los posibles polígonos), ese es efectivamente el resultado y la función es correcta.}
\par{
Así como tomamos el último triángulo en la descomposición, podemos fijar cual es el anteúltimo.
Las posibles opciones van a ser exactamente esto, fijar cual es el anteúltimo triángulo, de forma tal que cumpla ciertas condiciones.
Notemos primero que si fijamos que un triángulo es el anteúltimo, y queríamos saber el mejor polígono con un triángulo como último, la cantidad de puntos históricos del mejor polígono con último y anteúltimo fijos, es igual a la cantidad de puntos históricos con el anteúltimo fijo como último más los puntos históricos dentro del triángulo originalmente último\footnote{Perdón por tanto, pero repetir esta frase hasta que se entienda.}. Más específicamente, sumamos los puntos históricos estrictamente contenidos y un vértice más que no comparten.
}
\par{Veremos ahora que condiciones debe cumplir el próximo triángulo para considerarse. Los triángulos tienen que ser último y anteúltimo, así que deben compartir un vértice. En particular llamamos a esta vértice ultimo-a (y en contraste los otros son base y ultimo-b). Ultimo-a viene antes en el orden definido por el vértice base. Por otro lado, la otra condición es que los segmentos que forman definan un ángulo menor a 180, y por ende se forme un polígono convexo. Esto lo vamos a chequear utilizando el producto cruz de vectores, al igual que en el algoritmo de Graham. 
Por lo visto anteriormente, podemos buscar las posibles opciones de triángulos solo recorriendo los vértices anteriores a ultimo-a en el orden definido por base, y luego tomamos el máximo sobre los cálculos que hacemos, para retornar esto.}

\subsection{Como chequear la cantidad de históricos y la validez}
Que alguien lo explique, no se.

\subsection{No nos repitamos}
\par{Al momento de describir los algoritmos anteriores vimos que, repetimos consultas de dos tipos:
Las de historicos-contenidos y las de mejor-con-ultimo. Esto es por la naturaleza recursiva de mejor-con-ultimo y las llamadas a historicos-contenidos que hace. Es decir, a priori, repetiríamos exactamente el mismo cálculo por repetirse los parámetros en distintos momentos de la ejecución.}
\par{La raíz de todo mal en las Ciencias de la Computación es repetir cálculos(bueno, justo despúes de la \quotes{premature optimization}\footnote{\url{https://en.wikiquote.org/wiki/Donald_Knuth}}). Intentaremos no repetirnos mediante el uso de la técnica de memoization (junto a la recusión, podríamos decir que se corresponde con la técnica de programación dinámica). Para los parametros que calculemos el resultado de las dos funciones mencionadas, vamos a almacenar este resultado en un arreglo de tamaño correspondiente. Luego, al momento de ser llamada, la función chequea si el resultado ya fue almacenado, o si debe computarse por primera vez. Esto reduce considerablemente la complejidad de nuestra solución. }


\subsection{Pseudocódigo}
\begin{algorithmic}
\Function{Solucion}{historicos[], enemigos[]}
	\State m_historicos_contenidos $\gets$ Matriz_3_dimensional_menos_inf() \Comment{Memoization de históricos contenidos, es una global}

	\State res $\gets$ $-\infty$

	\For{i = 0 to historicos.size()}
		\State res $\gets$ max(res, mejor_con_base(historicos, enemigos, i))
	\EndFor

\EndFunction

\Function{mejor_con_base}{historicos[], enemigos[], base}
	\State p_base $\gets$ historicos[base]
	\State historicos_arriba_der $\gets$ filtrar históricos arriba a la derecha de p_base
	\State ordenar historicos_arriba_der por ángulo polar desde p_base

	\State base_filtrada $\gets$ nuevo índice de p_base en el arreglo historicos_arriba_der
	\State h $\gets$ historicos_arriba_der.size()
	\If{h $\leq$ 2}
		\State \Return h
	\EndIf

	\State memo $\gets$ Matriz_2_dimensional_menos_inf() \Comment{Memoization de mejor_con_ultimo}
	\State res $\gets$ $-\infty$

	\For {i = 0 to h}
		\For{j = 0 to h}
			\If { i,j, base_filtrada son distintos entre si} \Comment{Forman un triangulo valido}
				\State res = max(res, mejor_con_ultimo(historicos, enemigos, memo, base_filtrada, i, j))
			\EndIf
		\EndFor
	\EndFor
\EndFunction
\Function{mejor_con_ultimo}{historicos[], enemigos[], memo, base, ultimo_a, ultimo_b}
	\If{memo[ultimo_a][ultimo_b] != $-\infty$ }
		\State \Return memo[ultimo_a][ultimo_b]
	\EndIf

	\State res $\gets$ $-\infty$
	\State \Comment{Cuantos estrictamente contenidos hay en el triángulo pasado por parámetro} 
	\State base_contenidos $\gets$ historicos_contenidos(historicos[base], historicos[ultimo_a], historicos[ultimo_b], historicos, enemigos) 

	\If {base_contenidos != -1}
		\For{i = 0 to ultimo_a}
			\If{i == base or i == ultimo_a}
				\State \textbf{continue}
			\EndIf

			\State contenidos $\gets$ historicos_contenidos(historicos[base], historicos[ultimo_a], historicos[i], historicos, enemigos)

			\If{contenidos != -1 and blablabla } \Comment{chequeamos que el polígono no nos quede cóncavo}
				res $\gets$ max(res, mejor_con_ultimo(historicos, enemigos, memo, base, i, ultimo_a) + 1 + base_contenidos);

			\EndIf

		\EndFor
	\EndIf
\EndFunction


\end{algorithmic}



\subsection{Complejidad}
Bla bla bla